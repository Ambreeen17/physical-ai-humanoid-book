{
  "assessment_type": "coding",
  "chapter": 2,
  "total_points": 10,
  "estimated_time_minutes": 45,
  "difficulty": "intermediate",
  "learning_objectives": ["LO2.1", "LO2.2", "LO2.3"],
  "tags": ["workspace_boundaries", "inverse_kinematics", "reachability", "visualization"],
  "prerequisites": ["lab2_2_starter.py", "forward_kinematics_implementation"],
  "description": "Extend the inverse kinematics solver from Lab 2.2 to handle workspace boundaries. When a target position is outside the reachable workspace, the system should detect this and return the closest reachable configuration.",
  "task_statement": "Implement a workspace reachability checker and closest configuration finder for a 2-DOF planar arm with link lengths L1 and L2. The function should determine if a target point is reachable, and if not, return the configuration that minimizes distance to the target.",
  "specifications": {
    "input_format": {
      "target_position": "[x, y] list or array",
      "link_lengths": "dict with 'L1' and 'L2' values",
      "joint_limits": "optional dict with 'q1_min', 'q1_max', 'q2_min', 'q2_max'"
    },
    "output_format": {
      "is_reachable": "bool",
      "configuration": "list [q1, q2] in radians if reachable",
      "closest_position": "[x, y] actual reached position",
      "distance_to_target": "float - Euclidean distance"
    },
    "constraints": {
      "link_lengths_positive": "L1 > 0, L2 > 0",
      "joint_limits": "Default: -pi to pi for each joint",
      "target_inside_workspace": "If unreachable, clamp to reachable boundary",
      "return_type": "Dictionary with keys: is_reachable, configuration, closest_position, distance_to_target"
    },
    "edge_cases": [
      "Target exactly at maximum reach (L1 + L2)",
      "Target at minimum reach (|L1 - L2|)",
      "Target at origin when L1 == L2 (singularity)",
      "Joint limits constraining reachable workspace"
    ]
  },
  "starter_code": "See lab2_2_starter.py - extend with new class/method",
  "expected_implementation": [
    "1. Compute maximum reach: L1 + L2",
    "2. Compute minimum reach: |L1 - L2|",
    "3. Check if target distance is within [min_reach, max_reach]",
    "4. If unreachable, compute closest point on reachable circle/arc",
    "5. If reachable, use existing IK solver",
    "6. Check joint limits and clamp if necessary"
  ],
  "rubric": {
    "total_points": 10,
    "criteria": [
      {
        "id": "reachability_check",
        "description": "Correct reachability check implementation",
        "max_points": 4,
        "levels": {
          "excellent_4pts": "Correctly computes min_reach and max_reach, properly handles all edge cases including joint limits and singularity regions",
          "proficient_3pts": "Correctly implements basic reachability check but may miss some edge cases or joint limit considerations",
          "developing_2pts": "Partial implementation with logical errors in distance computation or boundary conditions",
          "beginning_0pts": "Incorrect approach or code that does not compile/run"
        }
      },
      {
        "id": "closest_config",
        "description": "Closest configuration computation",
        "max_points": 4,
        "levels": {
          "excellent_4pts": "Correctly computes closest configuration using proper mathematical projection onto reachable set, handles all constraint cases",
          "proficient_3pts": "Correctly handles basic case but may not fully address constrained joint limits or complex boundary cases",
          "developing_2pts": "Implements some form of closest point search but with errors or incomplete handling of constraints",
          "beginning_0pts": "No implementation or fundamentally incorrect approach"
        }
      },
      {
        "id": "visualization",
        "description": "Workspace boundary visualization",
        "max_points": 2,
        "levels": {
          "excellent_2pts": "Clear visualization showing robot arm, target point, closest reachable point, and workspace boundary with legend",
          "proficient_1pt": "Basic visualization showing the key elements but may lack clarity or completeness",
          "beginning_0pts": "Missing visualization or non-functional plot"
        }
      }
    ]
  },
  "test_cases": [
    {
      "input": {
        "target_position": [1.5, 0.5],
        "link_lengths": {"L1": 1.0, "L2": 0.8}
      },
      "expected": {
        "is_reachable": true,
        "distance_to_target": 0.0
      }
    },
    {
      "input": {
        "target_position": [2.5, 0.0],
        "link_lengths": {"L1": 1.0, "L2": 0.8}
      },
      "expected": {
        "is_reachable": false,
        "distance_to_target": 0.7
      }
    },
    {
      "input": {
        "target_position": [0.1, 0.0],
        "link_lengths": {"L1": 1.0, "L2": 0.8}
      },
      "expected": {
        "is_reachable": false,
        "distance_to_target": 0.1
      }
    }
  ],
  "hints": [
    "For a 2-DOF arm, the reachable workspace is an annular region between radii |L1-L2| and L1+L2",
    "If target is outside the max radius, project onto the circle of radius L1+L2",
    "If target is inside the min radius, project onto the inner circle",
    "Use numpy.linalg.norm() for distance computations",
    "The closest point can be found by scaling the target position vector"
  ]
}
